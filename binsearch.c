#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include "types.h"
#include "const.h"
#include "util.h"
# define _POSIX_C_SOURCE 200809L

int serial_binsearch(int x,int v[],int t) {

int low,high,mid;
    low=0;
    high=t-1;

    while(low <= high)
    {
        mid = ( low + high ) / 2;

        if( v[mid] < x){
            low  = mid + 1;
        }else if ( x == v[mid]){
            return mid;
	}else{
	    high = mid - 1;
	}
    }
 if (low > high){
 	return -1;
	}
}

int parallel_binsearch(int x, int v[], int t, int proc) {
int chunkSize = t/proc;
int var;
int (*arrs)[64] = malloc( sizeof *arrs * proc );

for (int i = 0; i < proc; i++) {
    int start = i * chunkSize;
    int end = start + chunkSize - 1;
    if (i == proc - 1) {
        end = t - 1;
    }

    for (int j = start; j <= end; j++) {
        arrs[i][j-(chunkSize*i)] = v[j];
    }
}

for (int i = 0; i < proc; i++) {
    
    var = serial_binsearch(x, arrs[i], chunkSize);
    if (var>=0){
	return var+(chunkSize*i);
    }
}
}

int main(int argc, char** argv) {
	int num_exp = 0, num_pot = 0, num_pos = 0;
	int opt;
    /* TODO: move this time measurement to right before the execution of each binsearch algorithms
     * in your experiment code. It now stands here just for demonstrating time measurement. */
    clock_t cbegin = clock();

    printf("[binsearch] Starting up...\n");

    /* Get the number of CPU cores available */
    printf("[binsearch] Number of cores available: '%ld'\n",
           sysconf(_SC_NPROCESSORS_ONLN));

    /* TODO: parse arguments with getopt */
	while ((opt = getopt (argc, argv, "E:T:P:")) != -1)
	{
		switch (opt)
		{
			case 'E':
				num_exp = atoi(optarg);
				if(num_exp < 1) {
					printf("-E value out of range, exiting program\n");
					exit(-1);
				}
				break;
			case 'T':
				num_pot = atoi(optarg);
				if(num_pot < 3 || num_pot > 9){
					printf("-T value out of range, exiting program\n");
					exit(-1);
				}
				break;
			case 'P':
				num_pos = atoi(optarg);
				break;
			case '?':
				printf("please use -e <number of experiments> -t <exponent of size of array> -p <position to find in array>");
				break;
		}
	}
	if(num_pos < 0 || num_pos > pow(10,num_pot)){
		printf("-P value out of range, exiting program\n"); 
		exit(-1);
	}

    /* TODO: start datagen here as a child process. */
	int pid = fork();
	if(pid == 0){
		execvp("./datagen", argv);
	}
	else if (pid > 0){
		printf("datagen in action\n");
	}
	else if (pid < 0){
		fprintf(stderr, "Cannot make datagen child\n"); 
	}


    /* TODO: implement code for your experiments using data provided by datagen and your
     * serial and parallel versions of binsearch.
     * */
	char buf[30];
	int data_buf[1000];
	int fd,rc;
	struct sockaddr_un addr;
	fd = socket(AF_UNIX, SOCK_STREAM, 0);
  	if ( (fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
    	perror("socket error");
    	exit(-1);
  	}
	memset(&addr, 0, sizeof(addr));
  	addr.sun_family = AF_UNIX;
	strcpy(addr.sun_path, DSOCKET_PATH, sizeof(addr.sun_path));

  	if (connect(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
    	perror("connect error");
    	exit(-1);
  	}
	strcpy(buf, "BEGIN S ");
	strcat(buf, num_pot);
	write(fd, "BEGIN S %i", num_pot);

    /* TODO: connect to datagen and ask for the necessary data in each experiment round.
     * Create a Unix domain socket with DSOCKET_PATH (see const.h).
     * Talk to datagen using the messages specified in the assignment description document.
     * Read the values generated by datagen from the socket and use them to run your
     * experiments
     * */
	int aux = 0;
	int length = pow(10, num_pot);
	int datagen_array[length];
	

    /* Probe time elapsed. */
    clock_t cend = clock();

    // Time elapsed in miliseconds.
    double time_elapsed = ((double) (cend - cbegin) / CLOCKS_PER_SEC) * 1000;

    printf("Time elapsed '%lf' [ms].\n", time_elapsed);

    exit(0);
}
